Question 1:
I started thinking about this problem by iterating through different lengths `t` cutting out different ending letters each time but I quickly realized that this would only catch words that are in order of letters. Instead of thinking as `t` as a string I  started to think of it as a list of characters so I started by breaking `t` into a list. I then simply made sure that each letter was contained in `s`.
        In an interview I would specify what constitutes an anagram. If the letters from `t` could only be used once,I would remove the letter matching letter from `s` to make sure that a letter could not be counted twice. This is something I would want to clarify at the beginning of an interview. After reviewing this problem, I realized there was a better solution. By using the Counter class which is a subclass of dictionary, I can simply compare the Counter of each string. If the Counter of `t` minus the Counter of `s` is empty then we know `t` is contained in `s`. This solution also fixes the problem of duplicate letters. The runtime for this would be O(n) where n is the number of letters in `t` and `s` and the space would be O(1) since we are using dictionaries. 


Question 2:
        For this question I knew I needed to look through every variation of the string. I decided to do this by nesting a for loop to iterate through all the combinations of the string. I decided to make a separate function for finding out if the variations of the word is a palindrome or not. I then stored the palindrome only replacing it with a palindrome that was longer in length.
        This is another question that I would want to clarify with the interviewer. The problem doesn’t say what should be done with there are multiple palindromes of the greatest length. Right now I am only returning the first palindrome but I could easily add each to an array to return multiple palindromes of the same length. Since this problem contains a nested for loop, the runtime would be O(n^2) and the space would be O(n) where n is the length of the largest palindrome.


Question 3:
        This was a much more complex problem than the first two. I decided to go with Prim’s algorithm by optimizing one vertex at a time. After much thought, I decided to start with the first vertex and label it as visited. I then looped through the vertex’s edges to find the least edge weight to an unvisited vertex. 
Once the best edge was found I added it to an array holding my minimum spanning tree array, only returning the array once all vertices were visited. It took much more time to get started on this problem than the first two. After talking out the problem, I was able to realize that Prim’s algorithm could be used and was able to work the problem out one step at a time. The runtime for this problem would be O(log(n)) where n is the number of edges. The space would be O(n) since we store the minimum spanning tree, the visited vertices, and the best edge.


Question 4:
        This problem was difficult for me to picture at first. I actually got out a piece of paper to draw the example tree. This helped me to better visualize the problem and get started brainstorming solutions. I started by keeping track of each given node’s ancestor nodes. I iterated through the tree working my way up through both nodes ancestors until I found an ancestor that they both had in common.
        When working on test cases for this problem, I realized that I needed to test to make sure the node was in the tree. I did this by comparing the tree length to the node. As I’m writing this I am realizing that I should also check to make sure the root is valid number but that would be something I could ask the interviewer about if I was unsure. I also improved the space by not saving each ancestor to an array. Instead I compared the current ancestor of each node directly to each other until they are equal. The runtime of this would be O(n) where n is the number of nodes. The space complexity would be O(1) since we are only storing the lowest ancestor of each node.


Question 5:
        The last problem I started by iterating through the list and then looping back through to get the value of the `m`th from the last place. I realized that this wasn’t the most efficient method so I decided to rethink the problem. I realized that instead of looping back through the list after I got to the end, I could instead keep track of the value the `m`th from the end and return that value once I was at the end.
        Working this problem is an excellent example of how sometimes your first idea is not always the best. You should always be thinking of way to rethink problems to make them more efficient. The runtime of this problem is O(n) where n is the list length. The space would be O(n) where n is the list length since we are storing the current node.